#include "stack_$T.h"
#include <stdlib.h>

void stack_$T_resize(stack_$T* stack, size_t newsize) {
  stack->capacity = newsize;
  if (!stack->buffer)
    stack->buffer = CALLOC(newsize, sizeof(^T));
  else
    stack->buffer = REALLOC(stack->buffer, newsize * sizeof(^T));
}

stack_$T stack_$T_create() {
  stack_$T stack = (stack_$T) {
    .buffer = 0,
    .size = 0,
    .capacity = 10,
  };
  stack_$T_resize(&stack, stack.capacity);
  return stack;
}
void stack_$T_free(stack_$T* stack) {
  FREE(stack->buffer);
}
void stack_$T_push(stack_$T* stack, ^T val) {
  if (stack->size + 1 >= stack->capacity) stack_$T_resize(stack, stack->capacity * 2);
  stack->buffer[stack->size++] = val;
}
void stack_$T_pop(stack_$T* stack) {
  if (stack->size == 0) return;
  stack->size--;
}
result_stack_$T_top stack_$T_top(stack_$T* stack) {
  if (stack->size == 0) return result_err(stack_$T_top, "stack empty");
  return result_ok(stack_$T_top, stack->buffer[stack->size - 1]);
}
result_stack_$T_top stack_$T_top_offset(stack_$T* stack, int offset) {
  if (stack->size == 0) return result_err(stack_$T_top, "stack empty");
  if (stack->size <= offset) return result_err(stack_$T_top, "not enough elements");
  return result_ok(stack_$T_top, stack->buffer[stack->size - offset - 1]);
}
int stack_$T_empty(stack_$T* stack) {
  return stack->size == 0;
}
